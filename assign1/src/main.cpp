/**
 * Name: Shuangchang Li, Qiuan Wu
 * Assignment 1
 * 
 * I pledge my honor that I have abided by the Stevens Honor System.
 * 
**/
#include "header.hh"

t_global_variable global_var;
std::queue<t_product *> products;


int main(int argc, char **argv)
{

    /**
    • P1: Number of producer threads
    • P2: Number of consumer threads
    • P3: Total number of products to be generated by all producer threads
    • P4: Size of the queue to store products for both producer and consumer threads (0 for
    unlimited queue size)
    • P5: 0 or 1 for type of scheduling algorithm: 0 for First-Come-First-Serve, and 1 for
    Round-Robin
    • P6: Value of quantum used for round-robin scheduling
    • P7: Seed for random number generator
    **/

    if(argc != 8){
        std::cerr << "Number of Input in command line must be 8." << std::endl;
        return 0;
    }

    int nProducer_thread = atoi(argv[1]);
    int nConsumer_thread = atoi(argv[2]);
    int Total_product = atoi(argv[3]);
    int size_of_queue = atoi(argv[4]);
    int type_of_algorithm = atoi(argv[5]);
    int quantum = atoi(argv[6]);
    int seed = atoi(argv[7]);
    int *result;
    struct timespec finish;
    
    //checking input
    if (nProducer_thread <= 0){
        std::cerr << "Producer thread must be positive!" << std::endl;
        return 0;
    }

    if (nConsumer_thread <= 0){
        std::cerr << "Consumer thread must be positive!" << std::endl;
        return 0;
    }

    if (type_of_algorithm < 0 || type_of_algorithm >1){
        std::cerr << "Scheduel Algorithm must be zero or one!" << std::endl;
        return 0;
    }

    // rand for seed
    srandom(seed);

    // Init threads
    result = (int *) malloc(sizeof(int));
    pthread_t t_producer[nProducer_thread];
    pthread_t t_consumer[nConsumer_thread];

    // Declearing global varibles
    global_var.num_product = 0;
    global_var.max_product = Total_product;
    global_var.quantum = quantum;
    if(size_of_queue == 0){
        global_var.q_size = std::numeric_limits<double>::infinity();
    }else{
        global_var.q_size = size_of_queue;
    }
    global_var.p_consumed = 0;
    global_var.schedule = type_of_algorithm;
    global_var.c_minTime = 100000.0;
    global_var.c_maxTime = 0;
    global_var.total_waiting = 0;
    global_var.min_waiting = 100000.0;
    global_var.max_waiting = 0;
    global_var.turnSum = 0;

    pthread_mutex_init(&global_var.lock_q, NULL);
    pthread_cond_init(&global_var.q_notFull, NULL);
    pthread_cond_init(&global_var.q_notEmpty, NULL);
    
    //mark starting time
    clock_gettime(CLOCK_MONOTONIC, &global_var.start_time);

    // Init Producer and Consumer Threads
    
    for(int i = 0; i < nProducer_thread; i++){
        int erro = pthread_create(&t_producer[i], NULL, (void *(*)(void *))producer, &i);
        if(erro)
        {
            std::cout << "Producer Cannot be Created: " << erro << std::endl;
        }
    }

    clock_gettime(CLOCK_MONOTONIC, &global_var.c_Starttime);
    for(int i = 0; i < nConsumer_thread; i++){
        int erro = pthread_create(&t_consumer[i], NULL, (void *(*)(void *))consumer, &i);
        if(erro)
        {
            std::cout << "Consumer Cannot be Created: " << erro << std::endl;
        }
    }

    for(int i = 0; i < nProducer_thread; i++)
    {
        pthread_join(t_producer[i], (void **) &result);
    }

    clock_gettime(CLOCK_MONOTONIC, &finish);

    // Destroy mutexes
    pthread_cond_destroy(&global_var.q_notFull);
    pthread_cond_destroy(&global_var.q_notEmpty);
    pthread_mutex_destroy(&global_var.lock_q);

    float Total = (finish.tv_sec - global_var.start_time.tv_sec) + ((finish.tv_nsec - global_var.start_time.tv_nsec) / 1000000000.0);
    std::cout << std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "         INFORMATION         " << std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "Total consumption time:      " << (global_var.c_Stoptime.tv_sec - global_var.c_Starttime.tv_sec) + ((global_var.c_Stoptime.tv_nsec - global_var.c_Starttime.tv_nsec) / 1000000000.0) << "s" << std::endl;
    std::cout << "stoptime: " <<global_var.c_Stoptime.tv_sec << std::endl;
    std::cout << "c_starttime: " <<global_var.c_Starttime.tv_sec<<std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "Min turn-around time:        " << global_var.c_minTime << "s" << std::endl;
    std::cout << "Max turn-around time:        " << global_var.c_maxTime << "s" << std::endl;
    std::cout << "Avg turn-around time:        " << global_var.turnSum / global_var.max_product << "s" << std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "Min waiting:                 " << global_var.min_waiting << "s" << std::endl;
    std::cout << "Max waiting:                 " << global_var.max_waiting << "s" << std::endl;
    std::cout << "Avg wait time:               " << global_var.total_waiting / global_var.max_product << "s" << std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "Producer throughput:         " << (int) (global_var.max_product / ((global_var.p_Stoptime.tv_sec - global_var.start_time.tv_sec) + ((global_var.p_Stoptime.tv_nsec - global_var.start_time.tv_nsec) / 1000000000.0))) * 60 << " products per minute" << std::endl;
    std::cout << "Consumer throughput:         " << (int) (global_var.max_product / ((global_var.c_Stoptime.tv_sec - global_var.start_time.tv_sec) + ((global_var.c_Stoptime.tv_nsec - global_var.start_time.tv_nsec) / 1000000000.0))) * 60 << " products per minute" << std::endl;
    std::cout << "-----------------------------" << std::endl;
    std::cout << "Total run time:              " <<  Total << "s" << std::endl;
    std::cout << "-----------------------------" << std::endl;
    
}